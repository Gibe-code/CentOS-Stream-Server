
#System Calls Implementation

[Understanding System Calls](#Understanding-System-Calls)


## Understanding System Calls 

System calls are a critical mechanism that bridges user-space applications and the kernel in Unix-like operating systems such as CentOS Stream Server. They provide controlled access to low-level functionalities like file management, process control, and hardware communication. Using system calls ensures that applications can perform necessary tasks without compromising system security or stability.

## The lstat() System Call

For this project, I focused on exploring and implementing the lstat() system call. This call is similar to stat(), but with a key distinction: if the specified path is a symbolic link, lstat() returns information about the link itself, not the file it points to. This is particularly useful when managing or analyzing symbolic links in Linux file systems.

**Function prototype:**  

int lstat(const char *pathname, struct stat *statbuf);  
	• pathname: Path to the file or symbolic link.  
	• statbuf: Pointer to a struct stat where file information will be stored.  
If successful, lstat() returns 0. On failure, it returns -1 and sets errno.  

## My Implementation Process

To demonstrate the use of the lstat() system call on **CentOS Stream Server**, I wrote a C program that:  
	1. Creates a symbolic link to a file.  
	2. Uses lstat() to retrieve metadata about the symbolic link.  
	3. Compares it with stat() to show the difference in behavior.  

**Step 1: Install Development Tools**  
$ sudo dnf groupinstall "Development Tools"

**Step 2: Write the C Program**  
$ nano lstat_demo.c  
#include <stdio.h>  
#include <stdlib.h>  
#include <sys/stat.h>  
#include <unistd.h>  
int main() {  
    struct stat fileStat;  
// Create a test file and symbolic link  
    system("echo 'Sample file' > testfile.txt");  
    system("ln -s testfile.txt symlink.txt");  
// Use lstat to get info about symlink.txt  
    if (lstat("symlink.txt", &fileStat) == -1) {  
        perror("lstat failed");  
        exit(EXIT_FAILURE);  
    }  
printf("Information about symlink.txt using lstat():\n");  
    printf("File mode: %o\n", fileStat.st_mode);  
    printf("Link count: %lu\n", fileStat.st_nlink);  
    printf("File size: %ld bytes\n", fileStat.st_size);  
// Check if it's a symbolic link  
    if (S_ISLNK(fileStat.st_mode)) {  
        printf("Confirmed: symlink.txt is a symbolic link.\n");  
    } else {  
        printf("symlink.txt is not a symbolic link.\n");  
    }  
return 0;  
}  

Step 3: Compile and Run  
$ gcc lstat_demo.c -o lstat_demo  
$ ./lstat_demo  

## Program Output  

Information about symlink.txt using lstat():  
File mode: 120777  
Link count: 1  
File size: 11 bytes  
Confirmed: symlink.txt is a symbolic link.  

## Observations and Learning

From this implementation, I observed several key points:  
	• lstat() accurately retrieves information about the symbolic link itself, including its file mode, link count, and the size of the link (which reflects the length of the path it points to).  
	• In contrast, using stat() would have returned metadata about the target file (testfile.txt), not the link.  
	• The mode 120777 indicates it is a symbolic link (12 prefix) with standard read/write/execute permissions.  
	• This functionality is important in file management utilities, backup systems, and security scanners, where distinguishing links from actual files is critical.  

## Conclusion

This project helped reinforce my understanding of how file system-related system calls work at the kernel level. CentOS Stream Server, being POSIX-compliant and closely tied to RHEL standards, behaves consistently with expectations in this area. Using lstat() offers precise control when working with symbolic links, an essential skill for system administrators and developers.
By working directly with low-level system calls in CentOS Stream Server, I gained deeper appreciation for the power and precision of UNIX-based operating systems, especially in handling files, permissions, and links.
